"use strict"; function _toConsumableArray(t) { if (Array.isArray(t)) { for (var e = 0, i = Array(t.length); e < t.length; e++)i[e] = t[e]; return i } return Array.from(t) } var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _slicedToArray = function () { function t(t, e) { var i = [], n = !0, r = !1, o = void 0; try { for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0); } catch (l) { r = !0, o = l } finally { try { !n && a["return"] && a["return"]() } finally { if (r) throw o } } return i } return function (e, i) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, i); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(); !function () { function t(t) { function e(t, e) { if (t.data && (!t.data.staticClass || t.data.staticClass.indexOf("ignore") === -1)) { var i = t.data.staticClass ? t.data.staticClass + " " : ""; t.data.staticClass = i + e } } function i(t) { return t.__underlying_element } var n = { options: { type: Object, "default": { layoutMode: "masonry", masonry: { gutter: 10 } } }, itemSelector: { type: String, "default": "item" }, list: { type: Array, required: !0 } }, r = { name: "isotope", props: n, render: function (t) { var i = this, n = {}, r = this.prevChildren = this.children, o = this.$slots["default"] || [], s = this.children = [], a = this.removedKeys = []; o.forEach(function (t) { return e(t, i.itemSelector) }); for (var l = 0; l < o.length; l++) { var u = o[l]; if (u.tag) if (null != u.key && 0 !== String(u.key).indexOf("__vlist")) s.push(u), n[u.key] = u; else { var f = u.componentOptions, c = f ? f.Ctor.options.name || f.tag || "" : u.tag; console.log("Warning template error: isotope children must be keyed: <" + c + ">") } } var d = this.displayChildren = [].concat(s); if (r) for (var h = 0; h < r.length; h++) { var y = r[h]; n[y.key] || (d.splice(h, 0, y), a.push(y.key)) } return t("div", null, d) }, mounted: function () { var e = this, n = Object.assign({}, this.compiledOptions), r = function (t) { Object.entries(t).forEach(function (n) { var r = _slicedToArray(n, 2), o = r[0], s = r[1]; t[o] = function (t) { var n = i(t); return s.call(e, n.vm, n.index) } }) }; r(n.getSortData || {}), r(n.getFilterData || {}), this._isotopeOptions = n, n.filter && (n.filter = this.buildFilterFunction(n.filter)), this.$nextTick(function () { e.link(), e.listen(); var i = new t(e.$el, n); i._requestUpdate = function () { i._willUpdate || (i._willUpdate = !0, e.$nextTick(function () { i.arrange(), i._willUpdate = !1 })) }, e.iso = i }) }, beforeDestroy: function () { this._listeners.forEach(function (t) { t() }), this._filterlistener && this._filterlistener(), this.iso = null }, beforeUpdate: function () { this._oldChidren = Array.prototype.slice.call(this.$el.children) }, updated: function () { var t = this; if (this.iso) { var e = [].concat(_toConsumableArray(this.$el.children)), i = e.filter(function (e) { return !(t._oldChidren.indexOf(e) !== -1) }), n = this.removedKeys.map(function (e) { return Array.from(t.$el.children).find(function (t) { return t.__vue__ && t.__vue__.$vnode.key === e }) }); this.cleanupNodes(), this.link(), (n.length || i.length) && (this.listen(), this.iso.remove(n), this.iso.insert(i), this.iso._requestUpdate()) } }, methods: { cleanupNodes: function () { var t = this; this.removedKeys.reverse(), this._vnode.children = this._vnode.children.filter(function (e) { return !(t.removedKeys.indexOf(e.key) !== -1) }), this.$children = this.$children.filter(function (e) { return !(t.removedKeys.indexOf(e.$vnode.key) !== -1) }) }, link: function () { var t = this, e = this.$slots["default"] || []; e.filter(function (t) { return t.data && t.data.staticClass && !(t.data.staticClass.indexOf("ignore") !== -1) }).forEach(function (e, i) { var n = e.elm; n && (n.__underlying_element = { vm: t.list[i], index: i }) }) }, listen: function () { var t = this; this._listeners = Object.values(this.compiledOptions.getSortData || {}).map(function (e) { return Array.from(t.$el.children).map(function (i, n) { return t.$watch(function () { return e(i) }, function () { t.iso.updateSortData() }) }) }).flat() }, sort: function o(t) { var o = t; "string" == typeof t && (o = { sortBy: t }), this.arrange(o), this.$emit("sort", t) }, buildFilterFunction: function (t) { var e = this._isotopeOptions.getFilterData[t]; return e }, filter: function s(t) { var s = this.buildFilterFunction(t); this.arrange({ filter: s }), this.$emit("filter", t) }, unfilter: function () { this.arrange({ filter: function () { return !0 } }), this.$emit("filter", null) }, layout: function a(t) { var a = t; "string" == typeof t && (a = { layoutMode: t }), this.arrange(a), this.$emit("layout", a) }, arrange: function (t) { this.iso.arrange(t), this.$emit("arrange", t) }, shuffle: function () { this.iso.shuffle(), this.$emit("shuffle"), this.$emit("sort", null) }, getFilteredItemElements: function () { return this.iso.getFilteredItemElements() }, getElementItems: function () { return this.iso.getElementItems() } }, computed: { compiledOptions: function () { var t = Object.assign({}, this.options, { itemSelector: "." + this.itemSelector, isJQueryFiltering: !1 }); return Object.entries(t.getSortData || {}).forEach(function (e) { var i = _slicedToArray(e, 2), n = i[0], r = i[1]; "string" == typeof r && (t.getSortData[n] = function (t) { return t[r] }) }), t } } }; return r } if (typeof exports == "object") { var e = require("isotope-layout"); module.exports = t(e) } else if ("function" == typeof define && define.amd) define(["Isotope"], function (e) { return t(e) }); else if (window.Vue && window.Isotope) { var i = t(window.Isotope); Vue.component("isotope", i) } }();